import { useState } from 'react';
import * as pdfjsLib from 'pdfjs-dist';
// Import worker as a URL for Vite
import workerUrl from 'pdfjs-dist/build/pdf.worker.min.mjs?url';

// Configure PDF.js worker
pdfjsLib.GlobalWorkerOptions.workerSrc = workerUrl;

/**
 * Study Coach MVP Component
 * 
 * A single-page study coach that helps learners practice recall:
 * 1. Upload PDF ‚Üí Extract text
 * 2. Enter study goal
 * 3. Generate and display relevant passages
 * 4. Show comprehension questions
 * 5. Evaluate answers and provide feedback
 */
function Study() {
  // Stage management: "upload" | "goal" | "reading" | "quiz" | "feedback"
  const [stage, setStage] = useState("upload");
  
  // Document text extracted from PDF
  const [text, setText] = useState("");
  
  // User's study goal
  const [goal, setGoal] = useState("");
  
  // Passages generated by GPT
  const [passages, setPassages] = useState([]);
  
  // Questions generated by GPT
  const [questions, setQuestions] = useState([]);
  
  // User's answers to questions
  const [answers, setAnswers] = useState(["", "", ""]);
  
  // Feedback from GPT evaluation
  const [feedback, setFeedback] = useState([]);
  
  // Loading states
  const [isExtracting, setIsExtracting] = useState(false);
  const [isGenerating, setIsGenerating] = useState(false);
  const [isEvaluating, setIsEvaluating] = useState(false);
  
  // Error state
  const [error, setError] = useState("");

  // Simple inline styles
  const styles = {
    container: {
      minHeight: '100vh',
      background: 'linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%)',
      padding: '32px 16px',
    },
    wrapper: {
      maxWidth: '900px',
      margin: '0 auto',
    },
    header: {
      textAlign: 'center',
      marginBottom: '32px',
    },
    title: {
      fontSize: '36px',
      fontWeight: 'bold',
      color: '#333',
      marginBottom: '8px',
    },
    subtitle: {
      color: '#666',
      fontSize: '16px',
    },
    card: {
      background: 'white',
      borderRadius: '8px',
      boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
      padding: '32px',
      marginBottom: '24px',
    },
    heading: {
      fontSize: '24px',
      fontWeight: '600',
      color: '#333',
      marginBottom: '16px',
    },
    text: {
      color: '#666',
      marginBottom: '24px',
      lineHeight: '1.6',
    },
    input: {
      width: '100%',
      padding: '12px',
      border: '1px solid #ddd',
      borderRadius: '6px',
      fontSize: '16px',
      fontFamily: 'inherit',
      resize: 'vertical',
    },
    textarea: {
      width: '100%',
      padding: '12px',
      border: '1px solid #ddd',
      borderRadius: '6px',
      fontSize: '16px',
      fontFamily: 'inherit',
      resize: 'vertical',
      minHeight: '100px',
    },
    button: {
      width: '100%',
      padding: '12px 24px',
      background: '#4f46e5',
      color: 'white',
      border: 'none',
      borderRadius: '6px',
      fontSize: '16px',
      fontWeight: '600',
      cursor: 'pointer',
      marginTop: '24px',
    },
    buttonDisabled: {
      background: '#999',
      cursor: 'not-allowed',
    },
    buttonHover: {
      background: '#4338ca',
    },
    errorBox: {
      padding: '16px',
      background: '#fee',
      border: '1px solid #fcc',
      borderRadius: '6px',
      color: '#c33',
      marginBottom: '24px',
    },
    successBox: {
      padding: '16px',
      background: '#efe',
      border: '1px solid #cfc',
      borderRadius: '6px',
      color: '#3c3',
      marginTop: '16px',
    },
    progressContainer: {
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'space-between',
      marginBottom: '32px',
    },
    progressStep: {
      display: 'flex',
      alignItems: 'center',
      flex: 1,
    },
    progressCircle: {
      width: '40px',
      height: '40px',
      borderRadius: '50%',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      fontWeight: '600',
      fontSize: '16px',
    },
    progressLine: {
      flex: 1,
      height: '4px',
      margin: '0 8px',
    },
    passageBox: {
      padding: '24px',
      background: '#f9f9f9',
      borderRadius: '6px',
      border: '1px solid #e0e0e0',
      marginBottom: '24px',
    },
    passageTitle: {
      fontWeight: '600',
      fontSize: '18px',
      color: '#333',
      marginBottom: '12px',
    },
    passageText: {
      color: '#555',
      lineHeight: '1.8',
      whiteSpace: 'pre-wrap',
    },
    scoreBadge: {
      padding: '6px 12px',
      borderRadius: '20px',
      fontSize: '14px',
      fontWeight: '600',
    },
    uploadArea: {
      border: '2px dashed #ccc',
      borderRadius: '8px',
      padding: '48px',
      textAlign: 'center',
      cursor: 'pointer',
    },
    spinner: {
      border: '3px solid #f3f3f3',
      borderTop: '3px solid #4f46e5',
      borderRadius: '50%',
      width: '32px',
      height: '32px',
      animation: 'spin 1s linear infinite',
      margin: '16px auto',
    },
  };

  /**
   * Extract text from uploaded PDF file
   * Uses pdfjs-dist to parse PDF in the browser
   */
  const extractTextFromPDF = async (file) => {
    setIsExtracting(true);
    setError("");
    
    try {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      
      let fullText = "";
      
      // Extract text from all pages
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        const page = await pdf.getPage(pageNum);
        const textContent = await page.getTextContent();
        const pageText = textContent.items
          .map(item => item.str)
          .join(" ");
        fullText += pageText + "\n";
      }
      
      if (!fullText.trim()) {
        throw new Error("No text could be extracted from the PDF. Please ensure the PDF contains readable text.");
      }
      
      setText(fullText);
      setStage("goal");
    } catch (err) {
      setError(`Failed to extract text: ${err.message}`);
      console.error("PDF extraction error:", err);
    } finally {
      setIsExtracting(false);
    }
  };

  /**
   * Handle file upload
   */
  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    if (!file) return;
    
    if (file.type !== "application/pdf") {
      setError("Please upload a PDF file.");
      return;
    }
    
    extractTextFromPDF(file);
  };

  /**
   * Generate passages and questions from the study text and goal
   * Calls OpenAI API to get relevant passages and comprehension questions
   */
  const generateQuestions = async () => {
    if (!goal.trim()) {
      setError("Please enter a study goal.");
      return;
    }
    
    setIsGenerating(true);
    setError("");
    
    try {
      const apiKey = import.meta.env.VITE_OPENAI_API_KEY;
      if (!apiKey) {
        throw new Error("OpenAI API key not found. Please add VITE_OPENAI_API_KEY to your .env file.");
      }
      
      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: "gpt-5-nano",
          messages: [
            {
              role: "system",
              content: "You are a study coach that helps learners develop deep understanding through recall practice. Always respond with valid JSON only, no additional text."
            },
            {
              role: "user",
              content: `Given this study text:\n${text.substring(0, 8000)}\n\nand the user's goal: ${goal}\n\nSelect three short relevant passages (max 250 words each) and generate three short-answer questions to test comprehension. Return structured JSON in this exact format: {"passages": ["passage 1 text", "passage 2 text", "passage 3 text"], "questions": ["question 1", "question 2", "question 3"]}`
            }
          ],
          response_format: { type: "json_object" }
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error?.message || `API error: ${response.statusText}`);
      }
      
      const data = await response.json();
      const content = JSON.parse(data.choices[0].message.content);
      
      setPassages(content.passages || []);
      setQuestions(content.questions || []);
      setStage("reading");
    } catch (err) {
      setError(`Failed to generate questions: ${err.message}`);
      console.error("Question generation error:", err);
    } finally {
      setIsGenerating(false);
    }
  };

  /**
   * Evaluate user's answers and provide feedback
   * Calls OpenAI API to assess understanding
   */
  const evaluateAnswers = async () => {
    if (answers.some(answer => !answer.trim())) {
      setError("Please answer all questions before submitting.");
      return;
    }
    
    setIsEvaluating(true);
    setError("");
    
    try {
      const apiKey = import.meta.env.VITE_OPENAI_API_KEY;
      if (!apiKey) {
        throw new Error("OpenAI API key not found.");
      }
      
      


      const response = await fetch("https://api.openai.com/v1/chat/completions", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: "gpt-5-nano",
          messages: [
            {
              role: "system",
              content: "You are a study coach evaluating a student's understanding. Always respond with valid JSON only, no additional text."
            },
            {
              role: "user",
              content: `Here is the study text:\n${text.substring(0, 8000)}\n\nGoal: ${goal}\n\nQuestions:\n${questions.map((q, i) => `${i + 1}. ${q}`).join("\n")}\n\nUser Answers:\n${answers.map((a, i) => `${i + 1}. ${a}`).join("\n")}\n\nEvaluate each answer on a scale of 0-1 and give a brief 1-2 sentence feedback for each. Return a JSON object with a "feedback" key containing an array. Use this exact format: {"feedback": [{"question": "question text", "score": 0.8, "comment": "feedback text"}, ...]}`
            }
          ],
          response_format: { type: "json_object" }
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error?.message || `API error: ${response.statusText}`);
      }
      
      const data = await response.json();
      console.log("üîµ Raw API Response:", data);  // ADD THIS
      console.log("üîµ Message Content (raw string):", data.choices[0].message.content);  // ADD THIS

      const content = JSON.parse(data.choices[0].message.content);
      console.log("üü¢ Parsed Content:", content);  // ADD THIS
      console.log("üü¢ Is Array?", Array.isArray(content));  // ADD THIS
      console.log("üü¢ Content Type:", typeof content);  // ADD THIS
      
      // Handle both array and object with feedback key
      const feedbackArray = Array.isArray(content) 
  ? content 
  : (content.response || content.feedback ||content.results || []);
      console.log("üü° Extracted Feedback Array:", feedbackArray);  // ADD THIS
      console.log("üü° Feedback Array Length:", feedbackArray.length);
      
      setFeedback(feedbackArray);
      console.log("üü£ State updated, feedback set to:", feedbackArray);  // ADD THIS
      setStage("feedback");
      console.log("üü£ Stage set to 'feedback'");
      
    } catch (err) {
      setError(`Failed to evaluate answers: ${err.message}`);
      console.error("Evaluation error:", err);
    } finally {
      setIsEvaluating(false);
    }
  };

  /**
   * Handle answer input change
   */
  const handleAnswerChange = (index, value) => {
    const newAnswers = [...answers];
    newAnswers[index] = value;
    setAnswers(newAnswers);
  };

  /**
   * Reset the study session
   */
  const resetStudy = () => {
    setStage("upload");
    setText("");
    setGoal("");
    setPassages([]);
    setQuestions([]);
    setAnswers(["", "", ""]);
    setFeedback([]);
    setError("");
  };

  // Helper to get progress circle style
  const getProgressCircleStyle = (s, i) => {
    const stages = ["upload", "goal", "reading", "quiz", "feedback"];
    const currentIndex = stages.indexOf(stage);
    
    if (stage === s) {
      return { ...styles.progressCircle, background: '#4f46e5', color: 'white' };
    } else if (currentIndex > i) {
      return { ...styles.progressCircle, background: '#22c55e', color: 'white' };
    } else {
      return { ...styles.progressCircle, background: '#d1d5db', color: '#666' };
    }
  };

  // Helper to get progress line style
  const getProgressLineStyle = (i) => {
    const stages = ["upload", "goal", "reading", "quiz", "feedback"];
    const currentIndex = stages.indexOf(stage);
    
    if (currentIndex > i) {
      return { ...styles.progressLine, background: '#22c55e' };
    } else {
      return { ...styles.progressLine, background: '#d1d5db' };
    }
  };

  // Helper to get score badge style
  const getScoreBadgeStyle = (score) => {
    const numScore = typeof score === 'number' ? score : parseFloat(score);
    if (numScore >= 0.8) {
      return { ...styles.scoreBadge, background: '#dcfce7', color: '#166534' };
    } else if (numScore >= 0.6) {
      return { ...styles.scoreBadge, background: '#fef3c7', color: '#92400e' };
    } else {
      return { ...styles.scoreBadge, background: '#fee2e2', color: '#991b1b' };
    }
  };

  return (
    <div style={styles.container}>
      <div style={styles.wrapper}>
        {/* Header */}
        <div style={styles.header}>
          <h1 style={styles.title}>Study Coach</h1>
          <p style={styles.subtitle}>Practice active recall to deepen your understanding</p>
        </div>

        {/* Progress Indicator */}
        <div style={styles.progressContainer}>
          {["upload", "goal", "reading", "quiz", "feedback"].map((s, i) => (
            <div key={s} style={styles.progressStep}>
              <div style={getProgressCircleStyle(s, i)}>
                {i + 1}
              </div>
              {i < 4 && <div style={getProgressLineStyle(i)} />}
            </div>
          ))}
        </div>

        {/* Error Display */}
        {error && (
          <div style={styles.errorBox}>
            {error}
          </div>
        )}

        {/* Stage 1: Upload */}
        {stage === "upload" && (
          <div style={styles.card}>
            <h2 style={styles.heading}>Step 1: Upload Your Study Material</h2>
            <p style={styles.text}>Upload a PDF document to begin your study session.</p>
            
            <div style={styles.uploadArea}>
              <input
                type="file"
                accept="application/pdf"
                onChange={handleFileUpload}
                style={{ display: 'none' }}
                id="pdf-upload"
                disabled={isExtracting}
              />
              <label htmlFor="pdf-upload" style={{ cursor: 'pointer' }}>
                <div style={{ fontSize: '48px', marginBottom: '16px' }}>üìÑ</div>
                <div style={{ fontSize: '18px', fontWeight: '500', color: '#333', marginBottom: '16px' }}>
                  {isExtracting ? "Extracting text..." : "Click to upload PDF"}
                </div>
                {isExtracting && (
                  <div style={styles.spinner}></div>
                )}
              </label>
            </div>
            
            {text && (
              <div style={styles.successBox}>
                ‚úì Text extracted successfully ({text.length} characters)
              </div>
            )}
          </div>
        )}

        {/* Stage 2: Goal */}
        {stage === "goal" && (
          <div style={styles.card}>
            <h2 style={styles.heading}>Step 2: Set Your Study Goal</h2>
            <p style={styles.text}>
              What would you like to focus on? This helps generate relevant passages and questions.
            </p>
            
            <textarea
              value={goal}
              onChange={(e) => setGoal(e.target.value)}
              placeholder="e.g., Understand the key concepts of machine learning, Focus on the historical context of World War II..."
              style={styles.textarea}
              rows="4"
            />
            
            <button
              onClick={generateQuestions}
              disabled={isGenerating || !goal.trim()}
              style={{
                ...styles.button,
                ...((isGenerating || !goal.trim()) ? styles.buttonDisabled : {}),
              }}
              onMouseEnter={(e) => {
                if (!isGenerating && goal.trim()) {
                  e.target.style.background = styles.buttonHover.background;
                }
              }}
              onMouseLeave={(e) => {
                if (!isGenerating && goal.trim()) {
                  e.target.style.background = styles.button.background;
                }
              }}
            >
              {isGenerating ? (
                <span>
                  <span style={{ display: 'inline-block', marginRight: '8px' }}>‚è≥</span>
                  Generating questions...
                </span>
              ) : (
                "Generate Study Materials"
              )}
            </button>
          </div>
        )}

        {/* Stage 3: Reading */}
        {stage === "reading" && (
          <div style={styles.card}>
            <h2 style={styles.heading}>Step 3: Read and Review</h2>
            <p style={styles.text}>
              Read through these passages carefully. When you're ready, click the button below to test your understanding.
            </p>
            
            <div style={{ marginBottom: '24px' }}>
              {passages.map((passage, index) => (
                <div key={index} style={styles.passageBox}>
                  <h3 style={styles.passageTitle}>
                    Passage {index + 1}
                  </h3>
                  <p style={styles.passageText}>{passage}</p>
                </div>
              ))}
            </div>
            
            <button
              onClick={() => setStage("quiz")}
              style={styles.button}
              onMouseEnter={(e) => {
                e.target.style.background = styles.buttonHover.background;
              }}
              onMouseLeave={(e) => {
                e.target.style.background = styles.button.background;
              }}
            >
              I'm Ready
            </button>
          </div>
        )}

        {/* Stage 4: Quiz */}
        {stage === "quiz" && (
          <div style={styles.card}>
            <h2 style={styles.heading}>Step 4: Answer the Questions</h2>
            <p style={styles.text}>
              Answer these questions based on what you read. Write short, thoughtful responses.
            </p>
            
            <div style={{ marginBottom: '24px' }}>
              {questions.map((question, index) => (
                <div key={index} style={styles.passageBox}>
                  <h3 style={styles.passageTitle}>
                    Question {index + 1}
                  </h3>
                  <p style={{ ...styles.text, marginBottom: '16px' }}>{question}</p>
                  <textarea
                    value={answers[index]}
                    onChange={(e) => handleAnswerChange(index, e.target.value)}
                    placeholder="Type your answer here..."
                    style={styles.textarea}
                    rows="4"
                  />
                </div>
              ))}
            </div>
            
            <button
              onClick={evaluateAnswers}
              disabled={isEvaluating || answers.some(a => !a.trim())}
              style={{
                ...styles.button,
                ...((isEvaluating || answers.some(a => !a.trim())) ? styles.buttonDisabled : {}),
              }}
              onMouseEnter={(e) => {
                if (!isEvaluating && !answers.some(a => !a.trim())) {
                  e.target.style.background = styles.buttonHover.background;
                }
              }}
              onMouseLeave={(e) => {
                if (!isEvaluating && !answers.some(a => !a.trim())) {
                  e.target.style.background = styles.button.background;
                }
              }}
            >
              {isEvaluating ? (
                <span>
                  <span style={{ display: 'inline-block', marginRight: '8px' }}>‚è≥</span>
                  Evaluating your answers...
                </span>
              ) : (
                "Submit Answers"
              )}
            </button>
          </div>
        )}

        {/* Stage 5: Feedback */}
        {stage === "feedback" && (
          <div style={styles.card}>
            <h2 style={styles.heading}>Step 5: Your Feedback</h2>
            <p style={styles.text}>
              Here's how you did and what you can improve:
            </p>
            

            <div style={{ marginBottom: '24px' }}>
              {feedback.map((item, index) => (
                <div key={index} style={styles.passageBox}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'start', marginBottom: '12px' }}>
                    <h3 style={styles.passageTitle}>
                      Question {index + 1}
                    </h3>
                    <span style={getScoreBadgeStyle(item.score)}>
                      Score: {typeof item.score === 'number' ? item.score.toFixed(1) : item.score}
                    </span>
                  </div>
                  <p style={{ ...styles.text, marginBottom: '8px' }}>{item.question || questions[index]}</p>
                  <p style={{ ...styles.text, fontStyle: 'italic', marginBottom: '12px', color: '#888' }}>
                    Your answer: {answers[index]}
                  </p>
                  <p style={{ ...styles.text, fontWeight: '500', color: '#333' }}>
                    {item.comment || item.feedback || "No feedback provided."}
                  </p>
                </div>
              ))}
            </div>
            
            <button
              onClick={resetStudy}
              style={styles.button}
              onMouseEnter={(e) => {
                e.target.style.background = styles.buttonHover.background;
              }}
              onMouseLeave={(e) => {
                e.target.style.background = styles.button.background;
              }}
            >
              Start New Study Session
            </button>
          </div>
        )}
      </div>

      <style>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
}

export default Study;
